<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>javascript</title>
</head>
<body>




    <!-- 참고 : 이건 css 작성할 수 있게 도와주는 태그 -->
    <style>

    </style>




    <!-- script 태그 : body tag 밑에 작성하기 
            - javascript 구문을 작성하게 도와주는 태그 -->
    <script>

        // 자바스크립트 주석 

            // 자바스크립트 주석 : 한줄 주석 
        
            /* 
                줄 내림 주석
            */


   /*
        자바스크립트 변수
        변수란? 
            데이터를 가르키는 주소 
            이 주소를 따라가면 - 데이터가 있음 
            변수는 데이터를 저장
            주소를 알면 -> 데이터를 가져올 수 있음. 
            
            변수를 선언 -> 변수에 데이터를 정의 -> 이걸 메모리에 담아둔다. 

            메모리 공간에 고유 번호가 있음. 저장해 라고 하면? ❓❓❓ 
            cs 50 다시 들어보자 ⭐⭐⭐⭐⭐⭐⭐⭐⭐ 


        메모리는? 
            '프로그램이 실행되는 동안' 필요한 데이터와 명령어를 저장 
            '전원이 들어와 있는 동안' ❓❓❓ 
            이게 잘 안 느껴지는데 

        ram 
            cpu 가 데이터에 빠르게 접근하고, 사용할 수 있는 공간. 
            cpu 가 처리할 데이터 or 명령어를, '잠시', 저장하고, 사용하는 용도 
            전원이 꺼지면, 저장된 데이터가 사라진다. 


        변수 선언 
            
            `선언자 변수 이름 = 데이터;`

            var var1 = 1 ;
                1 이라는 값을 메모리에 저장
                1 이라는 값을 var1 이름으로저장 
                1 이라는 값에 접근할 수 있게, var1 이라는 변수명을 지정

            let let1 = 1; 

        
        [var vs let 차이] ⭐⭐⭐
            `var var1 = 1;` 이렇게 선언하면, (var1 에 data 1을 담는다.)
            var 는 '재선언' 이 가능함. 

            let 은 `재선언 불가` 함. 

            var 는 알고만 있고 `쓰지마` 
            let 위주로! ⭐⭐⭐⭐⭐ 

            - var 의 문제점
                var 로 작업했을 때, 변수명이 겹치는 경우 
                ex) 1번 팀원. var a; 변수를 선언 / 2번 팀원도 var a; 를 선언 -> 1번 팀원이 a 변수에 넣은게 사라짐. 


        [값을 넣지 않고 변수의 이름을 먼저 선언 > 나중에 값을 넣기! 가능] ⭐⭐⭐
            - 선언 
            let let2;
            
            - 값 넣기 
            let2 = 1;


        [자바스크립트에서 변수를 선언할 때, let var `선언문` 을 꼭 사용⭐⭐⭐]
            - 키워드 없으면 -> '전역변수' 로 쓰임 -> 문제 발생. ⭐⭐⭐⭐⭐
            - 이 경우, '예상치 못 한 문제' 가 발생함 ⭐⭐⭐⭐⭐
            
            */
        

        // [html 상에서 변수를 로그로 확인해보기]
            console.log()
            console.log("브라우저 개발자 모드에서 콘솔 창에 보여줄 값을 넣기")


        // 선언 
            // 선언문 필수  
            // 선언문 중 let vs var 차이 : 선언, 재선언 가능 여부 에 따라 다름 
            //     var 는 재선언 가능 
            //     let 은 불가 
            //     쓸 때는 let 위주로 


        // 이렇게 하면 > 개발자 도구 > console 에서 확인 가능 
        let let2 = 2 ;
        console.log(let2); 


        // 문자 저장 
            // 숫자는 파랑, 글자는 검은색 ⭐⭐⭐ 

        let let4 = "나는 문자 저장";
        console.log(let4)



        // data type 을 확인 하려면? ⭐⭐⭐⭐⭐
            // 1) 개발자 도구에서 색깔이 다름 
            // 2) 함수 console.log(typeof 궁금한 변수)
        console.log(typeof let4)


        // data type 의 종류 
        //     1) 숫자 = number 
        //     2) 문자 = string 
        
        
        // boolean data type 
            // 참과 거짓, 전등 스위치 처럼, '맞다/틀리다' 로 값이 필요할 때, 
        let let5 = true;
        let let6 = false;
        
        console.log(typeof let5);


        // undefined data type
            // 변수 선언만 되고 메모리에 값이 저장이 없으면 -> undefined
            // '값이 없다.' 응? 왜 없지? 값 없는게 확인 안 될 때. '자동으로 할당되는 data type'
            // '값 없이 선언' 되었을 때 -> 자동적으로 들어가는 데이터 타입 ⭐⭐⭐⭐⭐ 
        let let7 ;
        console.log(let7) ;


        // null data type
            // undefined 와 같이, 값이 없음을 나타내는 타입. ❓ 뭐가 다를까?  
            // '개발자' 가 변수에 '값이 없음'을 '의도적'으로 나타낼 때 쓴다. ⭐⭐⭐ 
        let let8 = null;
        

        // data type 별 크기(byte) (엄청 외울건 아님)
            // 숫자 타입 : 8byte.
            // 문자열 : 길이에 따라 다름. 대략 2byte 이상의 크기. 
            // boolean : 1byte. (true, false, 둘 중 하나임.)
            // null : 0byte 
            // undefined : 0byte (값이 없으니까~)

            // 이건 나중에, 블록체인 들어갔을 때, byte padding 기법을 볼 것 임. byte data 를 전송하거나 저장할 때, 일정한 크기의 블록으로 나누어서, 각 블록의 크기를 맞춰서 사용할 것임. 
            // byte padding 기법이 있는 이유는, data 를 전송할 때, '보안성 및 속도' 를 향상 시킬 수 있기 때문 ⭐
            // byte padding 공부 하진 마!!!!! 

            // 암호화를 할 때, 'sha-256' 함수를 사용할 것 임. 
            

        // [🟦 심플 과제 ]
        // 1) let 선언문으로 type1 이라는 이름의 변수 만들고 (값 없이, 선언만)
        // 2) 그 밑에, console.log() 로 type1 '변수의 값' 을 확인하고 
        // 3) 그 밑에, 5 라는 값을 할당하고, 
        // 4) 다시 console.log 로 확인 
        // 5) 다시, typeof 와 console.log 로 datatype 을 확인 
        // 6) 그 다음, 밑에 "본인 이름" 을 type1 변수에 대입 
        // 7) 그 다음, type1 넣은 걸, console.log() 확인 


        // [✅ 오늘 해볼 것 : 변수라는 걸 100번 손에 익을 때 까지 쓰기 ⭐⭐⭐⭐⭐]

        // 1. let 선언문을 사용해서, type1 변수 선언(값 없이)
        let type1 ;
        
        // 2. console.log() 로 type1 변수 값 확인 
        console.log(type1)

        // 3. let 선언문 사용해서, type1 변수에 '5' 를 할당 ⭐⭐⭐⭐⭐
            // 아! let 을 빈 변수로 선언하면, 값을 할 당 할 때는 let 을 빼줘야 한다!  
        type1 = 5;

        // 4. console.log 로 값 확인 
        console.log(type1)

        // 5. typeof 와 console.log 로 datatepe 확인 
        console.log(typeof type1)

        // 6. "정덕진" 을 type1 변수에 대입
        type1 = "정덕진"

        // 7. console.log() 로 확인 
        console.log(type1)
        console.log(typeof type1)

        // ⭐ 포인트 : 변수에 들어가는 건, 이렇게, '변할 수 있는 값' 임. ⭐⭐⭐ 



        // 원시 기초 type 
            // string, number, bool, undefined, null
        

        // 🟦 객체 type ⭐⭐ 
            // 중괄호로 선언 ⭐⭐⭐
            // 이 객체 에는 값이 여러개, 들어갈 수 있음.  
        
            // 선언
            let obj = {a:1, b:2, c:3};

            // obj 객체의 a 값을 대입 하거나 가져오려면 ⭐⭐⭐ 
                // . 으로 객체의 값에 접근할 수 있음. ⭐⭐⭐⭐⭐ 
                
                // 값을 가져오기 
                    // 값을 가져올 때 'key' 값을 사용 ⭐⭐⭐⭐⭐ 
            console.log("obj : a : ", obj.a);
            console.log("obj : b : ", obj.b);
            console.log("obj : c : ", obj.c);
             
            // 값을 넣기
            obj.a = 10;

            // [값 넣기] 1) key 추가하면서 2) 해당 key 에 값 넣어주기 📛📛📛 
            obj.d = 20;



        // 🟦 배열 type    
            // '대괄호' 로 선언
            // 다양한 datatype 을 가질 수 있음. 
            // 배열 값의 '순서' 는 0 부터 -1 까지
            // 배열 값의 순서는 : 0 부터 '배열의 길이 -1' ⭐⭐ (0부터 시작하니까, 끝에도 -1)
            
            // 선언
                // 배열에 들어있는 값은 6개 임 
                // 순서는 0 부터 시작 
                // 순서는 0 에서 부터 5 까지 임. 
            let arr = [1, 2, 3, "1", "2", "3"]

            
            // 첫 번째 값을 가져오기 
                // 값을 가져올 때, 'index' 를 사용 ⭐⭐⭐
            console.log("arr[0]", arr[0]);
            console.log("arr[1]", arr[1]);
            console.log("arr[2]", arr[2]);
            console.log("arr[3]", arr[3]);

            // [값 넣기] 지금 배열에 있는 리스트 값의 '맨 뒤' 에 새로운 값이 추가 됨 📛📛📛📛📛
            arr.push("4");


        // 값 확인 
        console.log(obj);
        console.log(arr);


        // 🟦 객체, 배열은 '레퍼런스 타입' 이라고 함


        
        // 🟦 변수 이름 작성법
            // - 회사가서, '사수가 쓰는 표기법' 으로 하면 됨. 
            
            // - 케밥 표기법 (Kebab Case)
            // css class 이름은 보통 이렇게 ⭐⭐⭐⭐⭐ 
                // let item-box 

            // - 카멜 표기법 (Camel) (낙타표기법)
                // 변수명을 선언할 때, 자주, 사용하는 표기법
                // 구분되는 곳에 '대문자'
                let itemBox;

            // - 스네이크 표기법 (snake) (뱀 표기법)
                let item_box;

            // - 헝가리안 표기법 (사용도가 떨어짐)
                // datatype 을 변수명에 사용 
                let strItemBox;

            // - 파스칼 표기법 
                // react 에 들어가게 되면, 보게 될 것 ⭐⭐⭐⭐⭐ 
                // 컴포넌트 라는게 있음 ⭐⭐⭐⭐⭐ 
                let ItemBox;



        // '값을 갖고 할 수 있는 것'
            // ex) 숫자 끼리 빼고 더하고, 문자열을 더하고, 빼고 더하고
            // 아, 문자열을 빼고, 더하는 것도 가능! 
            
            // '연산을 할 때 사용'
                // +, -, *, /, %
                
                // + : 더하기
                let a = 3; 
                let b = 3; 

                // 값을 가져오고 싶으면, a와 b 에 작성한 것 처럼, 해당 변수명에 작성된 값을 가져올 수 있다. 
                let c = a + b;
                console.log(c);

                // '하나의 문자열' 로 더해 졌음. ⭐⭐⭐ 
                let text1 = "나는 ";
                let text2 = "배고프다.😥" ;
                console.log(text1 + text2);

                // 숫자 데이터, 사칙연산. 
                console.log(a - b);
                console.log(a * b);
                console.log(a / b); 
                    // 떨어지고 남은 '나머지 값'
                console.log(a % b); 
                

                // [연산자] ++, --, **
                    // ++ 하면, '1씩 값이 증가'
                    // ex) input 값 1 > ++ 하면 > output : 2가 됨
                    a++ ;
                    console.log(a)

                    // -- 하면 -> 이전 값에서 '1이 빠짐'
                    // ex) 이전값(input) : 2 > -- 연산 > 결과값 : 1
                    a--;
                    console.log(a)

                    // ** 하면 > '제곱' 이 된다. 
                    // a 에 3제곱을 해 -> 그 값을 a 에 대입!!! 
                    a = a ** 3;
                    // 시사점
                        // ⭐값이 변화하려면⭐, '대입' 을 해줘야 함 
                        // 다만, ++,-- 는, 대입 하지 않아도, 값이 변화함. ⭐⭐⭐⭐⭐   
                            // ++, -- 는 그 자체로 1이 더해짐 
                            // a+1; 이렇게 쓴다고 변수의 값이 변하진 않는다. 
                            // a = a+1; 이렇게 다른 연산자들은 값을 넣어줘야 함. 

                    // 값 변화 test
                    let test1 = 1;

                    // console.log(test1 + 1);
                    test1 = test1 + 1;
                    console.log(test1);

                    // a 의 3제곱값을 -> a 에 대입
                    a = a ** 3; 
                    console.log(a);


                
                // [값 비교 연산자]
                    // 요놈들은 암기 ⭐⭐⭐⭐⭐ 
                    // !, ==, ===, !=, !==, >, <

                    // ! 는 반전!
                        // 반전 시키는 것. 
                    let test2 = true;
                    let test3 = false;
                    // !를 붙이면, bool 값을 반전!
                    console.log(!test2);

                    // == 
                        // 이 둘이 같은지를 본다. 
                        // 값이 같으면 -> true
                        // 값이 다르면 -> false 를 반환
                    let test4 = 2;
                    let test5 = "2";
                    console.log(test4 == test5);
                        // 숫자2 랑 문자2 가 같다! 오잉? ❓❓❓❓❓❓ 


                    // === 
                        // 비교를 좀 더 확실하게 하는 연산자 ⭐⭐⭐⭐⭐ 
                        // == 는 '값' 만 비교함. ⭐⭐⭐ 
                        // === 는 'type' 까지 비교함. ⭐⭐⭐
                    console.log(test4 === test5);
                        // [해석] 
                            // == 을 쓰면, 숫자2 랑 문자2 를 구분 못 함. p
                            // === 을 쓰면, 숫자2 랑 문자 2를 구분 함. ⭐⭐⭐⭐⭐ 

                    // != 
                        // 같은지 비교함
                        // 원래, 같으면 -> true 를 보여줘야 함. 
                        // 근데 이건, != 니까 -> 같으면, false 를 보여줌.  
                        
                        // 값이 같으면 -> false
                        // 값이 다르면 -> ture
                        console.log(test4 != test5);
                        
                        
                    //  !==
                        // === 의 반대
                        // type 까지 확실히 비교 가능 ⭐⭐⭐⭐⭐ 
                        console.log(test4 !== test5);
                    
                    
                    // > , <
                        // 초과, 미만! 을 비교
                        // 값이 큰지, 작은지, 확인해줌. 
                        // 값이 크면 -> true
                        // 값이 작으면 -> false
                    let test6 = 5; 
                    let test7 = 5; 

                    console.log(test6 > test7);
                        // [해석] 6 이 7 보다 크니? -> 안 커 -> 결과값은 fasle!
                        // 비교연산자는 true, false 로 알려준다. ⭐⭐⭐⭐⭐ 

                    console.log(test6 < test7);
                        // [해석] 이건 true 나와야 함. 


                    // [비교 연산자] >=, <=, 
                        // = 는 꼭 뒤에⭐⭐ 
                        // 이상, 이하, 를 비교
                        // '크거나 혹시 같니?', '작거나, 혹시 같니?'
                    
                        console.log(test6 <= test7);
                        // [해석] test7 이 test 6 보다, 크거나, 혹시 같니? 

                    console.log(test6 >= test7);
                        // [해석] test6 이 test7 보다, 크거나, 혹시 같니? 




    </script>





</body>
</html>